/*
 * Copyright (C) 2022 Rick Busarow
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tangle.inject.gradle

import hermit.test.junit.HermitJUnit5
import io.kotest.matchers.string.shouldContain
import org.gradle.testkit.runner.BuildResult
import org.gradle.testkit.runner.GradleRunner
import org.gradle.testkit.runner.TaskOutcome
import org.intellij.lang.annotations.Language
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DynamicTest
import org.junit.jupiter.api.TestInfo
import java.io.File
import kotlin.properties.Delegates
import io.kotest.matchers.shouldBe as kotestShouldBe

val agpVersions = setOf(TestVersions.AGP)
val anvilVersions = setOf(TestVersions.ANVIL)
val gradleVersions = setOf(TestVersions.GRADLE)
val kotlinVersions = setOf(TestVersions.KOTLIN, "1.7.0", "1.7.10")

abstract class BasePluginTest : HermitJUnit5() {

  protected val activities = "api(\"androidx.activity:activity:${TestVersions.ACTIVITY}\")"
  protected val compose = "api(\"androidx.compose.ui:ui:${TestVersions.COMPOSE}\")"
  protected val fragments = "api(\"androidx.fragment:fragment:${TestVersions.FRAGMENT}\")"
  protected val viewModels =
    "api(\"androidx.lifecycle:lifecycle-viewmodel:${TestVersions.LIFECYCLE}\")"
  protected val workManager = "api(\"androidx.work:work-runtime:${TestVersions.WORK}\")"

  @PublishedApi
  internal var testInfo: TestInfo by Delegates.notNull()

  // This is automatically injected by JUnit5
  @BeforeEach
  internal fun injectTestInfo(testInfo: TestInfo) {
    this.testInfo = testInfo
  }

  fun BuildResult.shouldSucceed() {
    tasks.forEach { it.outcome shouldBe TaskOutcome.SUCCESS }
  }

  @Language("RegExp")
  fun BuildResult.tangleDeps(): List<String> = output
    .replace("[\\s\\S]*> Task :module:\\S*\\s*".toRegex(), "")
    .replace(
      "\\s*BUILD SUCCESSFUL in .*\\s*\\d* actionable task: \\d* executed\\s*".toRegex(), ""
    )
    .lines()
    .filterNot { it.isBlank() }
    .filterNot { it.startsWith("api androidx") }
    .filterNot { it.contains("com.squareup.anvil") }
    .sorted()

  fun GradleRunner.shouldFailWithMessage(expectedMessage: String) {

    val result = buildAndFail()

    result.tasks.forEach { it.outcome shouldBe TaskOutcome.FAILED }

    result.output.fixPath() shouldContain expectedMessage
  }

  fun GradleRunner.shouldFailWithMessage(expectedMessage: Regex) {

    val result = buildAndFail()

    result.tasks.forEach { it.outcome shouldBe TaskOutcome.FAILED }

    result.output.fixPath() shouldContain expectedMessage
  }

  inline fun test(
    crossinline action: TestScope.() -> Unit
  ): List<DynamicTest> =
    gradleVersions.flatMap { gradle ->
      kotlinVersions.flatMap { kotlin ->
        agpVersions.flatMap { agp ->
          anvilVersions.map { anvil ->
            val scope = TestScope(
              testInfo = testInfo,
              gradleVersion = gradle,
              kotlinVersion = kotlin,
              agpVersion = agp,
              anvilVersion = anvil
            )
            DynamicTest.dynamicTest(scope.toString()) {
              scope.testProjectDir.deleteRecursively()
              action.invoke(scope)
            }
          }
        }
      }
    }

  fun String.fixPath(): String = replace(File.separator, "/")

  infix fun <T, U : T> T.shouldBe(expected: U?) {
    /*
    Any AssertionError generated by this function will have this function at the top of its stacktrace.

    The actual call site for the assertion is always the _second_ line.

    So, we can catch the assertion error, remove this function from the stacktrace, and rethrow.
     */
    try {
      kotestShouldBe(expected)
    } catch (assertionError: AssertionError) {
      // remove this function from the stacktrace and rethrow
      assertionError.stackTrace = assertionError
        .stackTrace
        .drop(1)
        .toTypedArray()
      throw assertionError
    }
  }
}

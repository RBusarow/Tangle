/*
 * Copyright (C) 2022 Rick Busarow
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@file:Suppress("TooManyFunctions")
@file:OptIn(com.squareup.anvil.annotations.ExperimentalAnvilApi::class)
package tangle.inject.compiler

import com.squareup.anvil.annotations.ExperimentalAnvilApi
import com.squareup.anvil.compiler.internal.argumentType
import com.squareup.anvil.compiler.internal.asClassName
import com.squareup.anvil.compiler.internal.classDescriptor
import com.squareup.anvil.compiler.internal.fqNameOrNull
import com.squareup.anvil.compiler.internal.reference.AnnotationReference
import com.squareup.anvil.compiler.internal.reference.TypeReference
import com.squareup.anvil.compiler.internal.reference.TypeReference.Descriptor
import com.squareup.anvil.compiler.internal.reference.TypeReference.Psi
import com.squareup.anvil.compiler.internal.reference.asClassName
import com.squareup.anvil.compiler.internal.reference.toClassReference
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.MemberName
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.jvm.jvmSuppressWildcards
import org.jetbrains.kotlin.descriptors.ModuleDescriptor
import org.jetbrains.kotlin.resolve.constants.EnumValue
import org.jetbrains.kotlin.resolve.constants.KClassValue
import java.io.ByteArrayOutputStream
import kotlin.reflect.KClass

private fun FileSpec.writeToString(): String {
  val stream = ByteArrayOutputStream()
  stream.writer().use {
    writeTo(it)
  }
  return stream.toString()
}

private fun FileSpec.Builder.annotateFile(): FileSpec.Builder =
  addAnnotation(
    AnnotationSpec(Suppress::class) {
      addMember("\"DEPRECATION\"")
    }
  )
    .addAnnotation(
      AnnotationSpec(ClassName("kotlin", "OptIn")) {
        addMember("%L::class", ClassNames.internalTangleApi)
      }
    )

fun FileSpec.Companion.buildFile(
  packageName: String,
  fileName: String,
  block: FileSpec.Builder.() -> Unit
): String = """
   |// Generated by Tangle
   |// https://github.com/rbusarow/Tangle
   |
""".trimMargin() + builder(packageName, fileName)
  .annotateFile()
  .apply { block() }
  .build()
  .writeToString()

fun TypeSpec.Builder.addFunction(
  name: String,
  block: FunSpec.Builder.() -> Unit
): TypeSpec.Builder = addFunction(
  FunSpec.builder(name)
    .apply { block() }
    .build()
)

fun FunSpec(
  name: String,
  block: FunSpec.Builder.() -> Unit
): FunSpec = FunSpec.builder(name)
  .apply { block() }
  .build()

fun AnnotationSpec(
  name: ClassName,
  block: AnnotationSpec.Builder.() -> Unit
): AnnotationSpec = AnnotationSpec.builder(name)
  .apply { block() }
  .build()

fun AnnotationSpec(
  annotationClass: KClass<out Annotation>,
  block: AnnotationSpec.Builder.() -> Unit
): AnnotationSpec = AnnotationSpec.builder(annotationClass)
  .apply { block() }
  .build()

@OptIn(ExperimentalAnvilApi::class)
fun List<AnnotationReference>.qualifierAnnotationSpecs(
  module: ModuleDescriptor
): List<AnnotationSpec> = mapNotNull { annotationReference ->

  val fqName = annotationReference.fqName

  if (fqName == FqNames.inject) return@mapNotNull null

  val annotationClass = fqName.toClassReference(module)
  if (!annotationClass.isAnnotatedWith(FqNames.qualifier)) {
    return@mapNotNull null
  }

  AnnotationSpec(annotationReference.classReference.asClassName()) {
    annotationReference.arguments
      .forEach { arg ->
        when (val value = arg.value<Any>()) {
          is KClassValue -> {
            val className = value.argumentType(module).classDescriptor().asClassName()
            addMember("${arg.resolvedName} = %T::class", className)
          }

          is EnumValue -> {
            val enumMember = MemberName(
              enclosingClassName = value.enumClassId.asSingleFqName()
                .asClassName(module),
              simpleName = value.enumEntryName.asString()
            )
            addMember("${arg.resolvedName} = %M", enumMember)
          }
          // String, int, long, ... other primitives.
          is String -> addMember("${arg.resolvedName} = %S", value)
          is Char -> addMember("${arg.resolvedName} = '%L'", value)
          else -> addMember("${arg.resolvedName} = %L", value)
        }
      }
  }
}

internal fun TypeName.withJvmSuppressWildcardsIfNeeded(
  module: ModuleDescriptor,
  typeReference: TypeReference
): TypeName {
  // If the parameter is annotated with @JvmSuppressWildcards, then add the annotation
  // to our type so that this information is forwarded when our Factory is compiled.
  val hasJvmSuppressWildcards = when (typeReference) {
    is Descriptor -> typeReference.type.annotations.hasAnnotation(FqNames.jvmSuppressWildcards)
    is Psi ->
      typeReference.type.annotationEntries
        .any { it.fqNameOrNull(module) == FqNames.jvmSuppressWildcards }
  }

  // Add the @JvmSuppressWildcards annotation even for simple generic return types like
  // Set<String>. This avoids some edge cases where Dagger chokes.
  val isGenericType = typeReference.isGenericType()

  // Same for functions.
  val isFunctionType = typeReference.isFunctionType()

  return when {
    hasJvmSuppressWildcards || isGenericType || isFunctionType -> this.jvmSuppressWildcards()
    else -> this
  }
}

fun ClassName.generateSimpleNameString(
  separator: String = "_"
): String = simpleNames.joinToString(separator)

fun TypeSpec.Builder.addContributesTo(
  scopeClassName: ClassName
): TypeSpec.Builder = addAnnotation(
  AnnotationSpec.builder(ClassNames.contributesTo)
    .addMember("%T::class", scopeClassName)
    .build()
)
